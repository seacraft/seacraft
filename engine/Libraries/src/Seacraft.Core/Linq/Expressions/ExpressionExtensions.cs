// Copyright 2023 Seacraft
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201CSoftware\u201D), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Seacraft.Core.Linq.Expressions
{
    public static class ExpressionExtensions
    {

        /// <summary>
        /// If f is generated by default, it is true.
        /// </summary>
        /// <typeparam name="T">object type</typeparam>
        /// <returns></returns>
        public static Expression<Func<T, bool>> True<T>() { return f => true; }


        /// <summary>
        /// If f is generated by default, it is false.
        /// </summary>
        /// <typeparam name="T">object type</typeparam>
        /// <returns></returns>
        public static Expression<Func<T, bool>> False<T>() { return f => false; }


        /// <summary>
        /// Create Or query conditions
        /// </summary>
        /// <typeparam name="T">object type</typeparam>
        /// <param name="leftExpression"> Left expression</param>
        /// <param name="rightExpression">right expression</param>
        /// <returns>The combined expression</returns>
        public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> leftExpression, Expression<Func<T, bool>> rightExpression)
        {
            return leftExpression.Compose(rightExpression, new Func<Expression, Expression, Expression>(Expression.OrElse));
        }

        /// <summary>
        /// Create And query conditions
        /// </summary>
        /// <typeparam name="T">object type</typeparam>
        /// <param name="leftExpression"> Left expression</param>
        /// <param name="rightExpression">right expression</param>
        /// <returns>The combined expression</returns>
        public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> leftExpression,
                                                         Expression<Func<T, bool>> rightExpression)
        {
            return leftExpression.Compose(rightExpression, new Func<Expression, Expression, Expression>(Expression.AndAlso));

        }

        public static Expression<Func<T, bool>> ToNot<T>(this Expression<Func<T, bool>> expression)
        {
            return Expression.Lambda<Func<T, bool>>(Expression.Not(expression.Body), expression.Parameters);
        }

        /// <summary>
        /// Expression Where specifies the query condition
        /// </summary>
        /// <typeparam name="IEntity"></typeparam>
        /// <typeparam name="IEntityKey"></typeparam>
        /// <param name="keyExpression"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static Expression<Func<IEntity, bool>> GetExpressionWhere<IEntity, IEntityKey>(this Expression<Func<IEntity, IEntityKey>> keyExpression, IEntityKey value)
        {
            var propertyBody = keyExpression.Body as MemberExpression;
            var parameterExpression = (propertyBody.Expression as ParameterExpression);
            var whereExpression = Expression.Lambda<Func<IEntity, bool>>(Expression.Equal(propertyBody, Expression.Constant(value)), parameterExpression);
            return whereExpression;
        }

        /// <summary>
        /// Combined expression
        /// </summary>
        /// <typeparam name="T">object type</typeparam>
        /// <param name="first">Current expression</param>
        /// <param name="second">Expressions to combine</param>
        /// <param name="merge">composition condition</param>
        /// <returns>The combined expression</returns>
        public static Expression<T> Compose<T>(this Expression<T> first, Expression<T> second, Func<Expression, Expression, Expression> merge)
        {
            Dictionary<ParameterExpression, ParameterExpression> map = first.Parameters.Select((ParameterExpression f, int i) => new
            {
                f = f,
                s = second.Parameters[i]
            }).ToDictionary(p => p.s, p => p.f);
            Expression arg = ParameterRebinder.ReplaceParameters(map, second.Body);
            return Expression.Lambda<T>(merge(first.Body, arg), first.Parameters);
        }

        /// <summary>
        /// Gets the expression object property name
        /// </summary>
        /// <typeparam name="IEntity"></typeparam>
        /// <typeparam name="IEntityKey"></typeparam>
        /// <param name="keyExpression"></param>
        /// <returns></returns>
        public static string GetPropertyName<IEntity, IEntityKey>(this Expression<Func<IEntity, IEntityKey>> keyExpression)
        where IEntity : class
        {
            var body = keyExpression.Body;
            switch (keyExpression.Body.NodeType)
            {
                case ExpressionType.MemberAccess:
                    return ((MemberExpression)body).Member.Name;
                case ExpressionType.Convert:
                    return ((MemberExpression)((UnaryExpression)body).Operand).Member.Name;
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        /// Gets expression object properties name
        /// </summary>
        /// <typeparam name="IEntity"></typeparam>
        /// <param name="keyExpression"></param>
        /// <returns></returns>
        public static string GetPropertyName<IEntity>(this Expression<Func<IEntity, object>> keyExpression)
        {
            var body = keyExpression.Body;
            switch (keyExpression.Body.NodeType)
            {
                case ExpressionType.MemberAccess:
                    return ((MemberExpression)body).Member.Name;
                case ExpressionType.Convert:
                    return ((MemberExpression)((UnaryExpression)body).Operand).Member.Name;
                default:
                    return null;
            }
        }

        /// <summary>
        /// Gets expression object properties
        /// </summary>
        /// <typeparam name="IEntity"></typeparam>
        /// <typeparam name="IEntityKey"></typeparam>
        /// <param name="keyExpression"></param>
        /// <returns></returns>
        public static PropertyInfo GetProperty<IEntity, IEntityKey>(this Expression<Func<IEntity, IEntityKey>> keyExpression)where IEntity : class
        {
            var type = typeof(IEntity);
            var property = type.GetProperty(keyExpression.GetPropertyName());
            return property;
        }
        /// <summary>
        /// Gets expression object properties
        /// </summary>
        /// <typeparam name="IEntity"></typeparam>
        /// <typeparam name="IEntityKey"></typeparam>
        /// <param name="keyExpression"></param>
        /// <returns></returns>
        public static PropertyInfo GetProperty<IEntity, IEntityKey>(this Expression<Func<IEntity, object>> keyExpression) where IEntity : class
        {
            var type = typeof(IEntity);
            var property = type.GetProperty(keyExpression.GetPropertyName());
            return property;
        }

        public static LambdaExpression ToLambdaExpression<TEntity>(this Expression<Func<TEntity, object>> objectExpr)
        {
            MemberExpression? operand = null;
            var body = (objectExpr.Body as UnaryExpression);
            var parameters = objectExpr.Parameters.ToList();
            if (body == null)
            {
                operand = objectExpr.Body as MemberExpression;
            }
            else
            {
                operand = body.Operand as MemberExpression;
            }
            var lambdaExpression = Expression.Lambda(operand, parameters);
            return lambdaExpression;
        }
    }
}
